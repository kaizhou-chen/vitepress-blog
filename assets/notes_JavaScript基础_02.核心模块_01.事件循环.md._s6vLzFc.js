import{_ as t,c as e,o as a,a4 as o}from"./chunks/framework.CAy_Deu4.js";const s="/vitepress-blog/assets/event_loop.Nu302pXM.png",m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"notes/JavaScript基础/02.核心模块/01.事件循环.md","filePath":"notes/JavaScript基础/02.核心模块/01.事件循环.md"}'),r={name:"notes/JavaScript基础/02.核心模块/01.事件循环.md"},n=o('<h3 id="单线程" tabindex="-1">单线程 <a class="header-anchor" href="#单线程" aria-label="Permalink to &quot;单线程&quot;">​</a></h3><p>为什么 JavaScript 是一门单线程语言？作为一门浏览器脚本语言，它的主要用途就是操作DOM和与用户交互，如果说js是多线程的话，那么它在操作DOM的时候，一个线程对DOM进行了新增操作，另一个线程对DOM进行了删除操作，那么这个时候js的处理将会变得十分复杂。为了避免这种情况，JavaScript一诞生就是单线程。</p><h3 id="任务队列" tabindex="-1">任务队列 <a class="header-anchor" href="#任务队列" aria-label="Permalink to &quot;任务队列&quot;">​</a></h3><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。所有任务可以分成两种，一种是同步任务，另一种是异步任务。</p><p><strong>同步任务</strong> 指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；所有同步任务都在主线程上执行，形成一个执行栈;</p><p><strong>异步任务</strong> 指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务</p><p><strong>当主线程将执行栈中所有的代码执行完之后，主线程将会去查看任务队列是否有任务。如果有，那么主线程会依次执行那些任务队列中的回调函数。</strong></p><h3 id="异步任务" tabindex="-1">异步任务 <a class="header-anchor" href="#异步任务" aria-label="Permalink to &quot;异步任务&quot;">​</a></h3><p>JavaScript 的异步任务根据事件分类分为两种：宏任务（MacroTask）和微任务（MicroTask）</p><ul><li><p><strong>宏任务</strong>：setTimeout、setInterval、requestAnimationFrame、requestIdleCallback、MessageChannel</p><p>UI 渲染（HTML Parsing）、I/O 事件（Mouse Events、Keyboard Events、Network Events）、setImmediate（Node.js）</p></li><li><p><strong>微任务</strong>：Promise.then（非 new Promise）、MutationObserver、process.nextTick（Node.js）</p></li></ul><p><strong>宏任务与微任务的优先级</strong></p><ul><li>宏任务的优先级高于微任务</li><li>每个宏任务执行完毕后都必须将当前的微任务队列清空</li></ul><h3 id="事件循环" tabindex="-1"><strong>事件循环</strong> <a class="header-anchor" href="#事件循环" aria-label="Permalink to &quot;**事件循环**&quot;">​</a></h3><p>主线程从&quot;任务队列&quot;中读取任务，这个过程是循环不断的，所以整个的这种运行机制又称为<strong>Event Loop（事件循环）。</strong></p><p><img src="'+s+'" alt="event_loop"></p><p>主线程运行时候，产生堆（Heap）和栈（Stack），栈中的代码调用各种外部 API，它们在任务队列中加入各种事件。只要栈中的代码执行完毕，主线程就会通过事件循环机制读取任务队列，依次执行那些事件所对应的回调函数。</p>',16),i=[n];function p(l,c,_,d,u,h){return a(),e("div",null,i)}const v=t(r,[["render",p]]);export{m as __pageData,v as default};
